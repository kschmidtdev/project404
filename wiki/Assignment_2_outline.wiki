#summary Our guideline/todo-list/task-list for 2nd assignment

= General Discussion =

I just wrote things in that 'I' thought made sense.  All of this is just rough.  We'll discuss it all at the next meeting. 



 
= Next Meeting =

Decide project manager for this assignment and criteria for following assignments

Discuss Features for game, and what we're going to use

Decide who is going to do what

= Timeline (and task assignment) =

|| _* Task name *_ ||  _* Additional info *_ || _* assigned to *_ || _* deadline || 
|| Read/Skim || Ch. 6, 7, & 8 || each of us || Wed ||
|| Feature Priority || (blah) || together || Wed ||
|| Guidelines || prog. languange & libraries: SDL, OGRE??, etc. || together || Wed ||
|| Game mechanics || (seen note below) || together || Thurs ||
|| Functional Requirements || Use cases/scenarios || ??? || Sun ||
|| UML || (self-explanatory) || ??? || Sun ||
|| Data Requirements || file formats || ??? || Sun ||
|| Non-functional requirements || (blah) || ??? || ??? ||
|| Glossary || (no one cares) || ??? || last ||


Gameplay mechanics - This is something that we do need to discuss.  I know that there is a general consensus that we shouldn't spend much time dwelling over how the game works.  I propose that we all (unless you don't want input) come up with 1 or 2 developed ideas about how the game should work and then we have a capped discussion (maybe 1hr) on deciding (and integrating ideas) - let me know what you think about this method (this rather decision must be made somehow) 



= Program Manager =

_???????_

= Assignment Details =

Assignment 2: Initial Requirements


* Functional requirements *

The functional requirements of your system detail what your software must do, but not how it will do it. You need the following information:

          * _List of actors_. The actors are the users of your system, divided into categories specific to your application. For each actor, list their goals and abilities with respect to the system.
          * _Usage scenarios_ for major features. A useful way to describe what a system will do without diving into the technical details of how it will do it is to write a description of typical "usage scenarios". These are sometimes called "use cases", and they describe a user would normally use the system. For this project, all your major project features must be described in usage scenarios with the following information:
                o Short name. For example: "Calculate GPA", "Set Time".
                o Informal description. Briefly described the feature in language that any SFU student could understand.
                o Actors. List the subset of actors who will most likely use the feature.
                o Use cases. Write use cases for the chosen actors. There should be at least one use case per actor. A feature might have more than one use case, e.g. you should definitely include a use-case for ordinary usage, and possibly some for abnormal usage when an error occurs.
                o Features used. List the features that this usage needs to work. A feature is a small, coherent piece of functionality of your system. For example, in a post-it note program, the "enter note" scenario might need features like "text edit box", "file save", "spell check", etc.
                o Exceptions: List what could reasonably go wrong, and what will be done if it does wrong. For example, if you ask the user to type in their phone number, and they type an invalid phone number, then you might print an error screen, clear what they have written, and ask them to do it again.
                o Screen mock-ups. Provide a sketch of how the feature will look on the screen when implemented. Sketch these with a drawing program, are a UI tool (like Visual BASIC), or make neat hand-drawn sketches.
            Think hard about these! These usage scenarios should cover all usage of your system --- if it is not in a use case, then it will not be in your system.  Even seemingly trivial features like "enter name and address in a form" can have hidden subtleties and issues that could come back to haunt you later if you don't handle them correctly from the beginning.

* UML Architectural Diagram *

Draw a UML diagram of the major classes your system, showing how they relate and what their main responsibilities are.
Use correct UML notation, and the diagrams should be drawn on a computer. You may use a UML drawing tool if you want (e.g. search the web for free ones).

* Data requirements *

This is a summary of all the I/O for your system, including file formats, what other systems (if any) yours interacts with, and how the user interacts with the system using the mouse/keyboard/wii-mote.

* Non-functional requirements *

Following the table in Figure 6.6 on page 125 of the textbook, describe your system's non-functional requirements. You may add more than what is in the table, but don't do less.

* Guidelines *

List technical guidelines (e.g. "the system will be written using Java Swing"), and security guidelines (what information should be protected, and how?). Also list any relevant ethical or legal issues. If you think some issues just do not apply to your system, then say so.

* Glossary *

Create a list of terms and definitions that precisely explain all the domain-specific terms and acronyms necessary to understand this document. These will be terms about your application, not about programming or software engineering. For example, in a grade-keeper application, terms like "course", "grade", "mark", and "GPA" need precise definitions.

* Feature Priority *

You will be going through three implementation iterations  during the course of this project --- "version 1", "version 2", and "version 3". For each feature you plan to implement, label it as being delivered in version 1, 2, or 3.

It is important that version 1 (and, of course, the following versions) be a usable and working version of your system. Version 1 does not have to do everything you want, but it you must implement all your promised version 1 features completely and correctly! Also keep in mind that version 3 is the final "gold" version of your project, and anything not implemented by version 3 will not be implemented at all (at least during this course!).

Think hard about this: good planning pays off. Do not over-promise (i.e. too many features) or under-deliver (too few features).

_Hint:_ If you have access to a good issue tracking tool, putting these features into it with labels "version 1", "version 2", etc. might be a good idea. 
















